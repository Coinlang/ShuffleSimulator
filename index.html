<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ShuffleSim v3.9</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <style>
        :root { --mac-bg: #F2F2F7; --mac-sidebar: #E5E5EA; --mac-border: #D1D1D6; --mac-blue: #007AFF; }
        body { font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif; background-color: var(--mac-bg); color: #1C1C1E; margin: 0; padding: 0; overflow: hidden; }
        .app-layout { display: flex; flex-direction: column; height: 100vh; }
        @media (min-width: 1024px) { .app-layout { flex-direction: row; } }
        aside { background-color: var(--mac-sidebar); border-bottom: 1px solid var(--mac-border); height: 48vh; overflow-y: auto; flex-shrink: 0; z-index: 20; padding: 12px; }
        @media (min-width: 1024px) { aside { width: 340px; height: 100vh; border-bottom: none; border-right: 1px solid var(--mac-border); padding: 20px; } }
        main { flex: 1; display: flex; flex-direction: column; overflow: hidden; background: #FFFFFF; }
        
        .stats-container { background-color: #FBFBFC; border-bottom: 1px solid #E5E5E7; display: flex; align-items: center; justify-content: space-between; height: 44px; padding: 0 16px; flex-shrink: 0; }
        .stats-inner { display: flex; gap: 12px; align-items: center; background: #EEEEF0; padding: 4px 14px; border-radius: 20px; border: 0.5px solid #D1D1D6; }

        .card-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(54px, 1fr)); gap: 12px; padding: 0 10px; }
        @media (min-width: 768px) { .card-grid { grid-template-columns: repeat(auto-fill, minmax(72px, 1fr)); gap: 14px; padding: 0; } }
        
        .card { aspect-ratio: 2/3; display: flex; flex-direction: column; align-items: center; justify-content: center; border-radius: 8px; font-weight: 800; font-size: 0.85rem; cursor: grab; background: #FFFFFF; border: 1.5px solid rgba(0,0,0,0.1); box-shadow: 0 1px 3px rgba(0,0,0,0.08); position: relative; overflow: hidden; }
        .suit-S { background-color: #E0E7FF !important; color: #312E81; border-color: #C7D2FE; }
        .suit-H { background-color: #FFE4E6 !important; color: #9F1239; border-color: #FECDD3; }
        .suit-C { background-color: #D1FAE5 !important; color: #065F46; border-color: #A7F3D0; }
        .suit-D { background-color: #FFEDD5 !important; color: #9A3412; border-color: #FED7AA; }

        .rank-badge { position: absolute; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; background-color: rgba(255,255,255,0.4); z-index: 1; border: 1px solid rgba(0,0,0,0.05); }
        .rank-label { position: relative; z-index: 2; }

        .slug-active { border: 2.5px solid var(--mac-blue) !important; z-index: 10; }
        .slug-next { border-right: none !important; border-top-right-radius: 0 !important; border-bottom-right-radius: 0 !important; margin-right: -13px; }
        .slug-prev { border-left: none !important; border-top-left-radius: 0 !important; border-bottom-left-radius: 0 !important; }

        .card-pos { position: absolute; bottom: 3px; right: 5px; font-size: 0.5rem; font-weight: 900; color: rgba(0,0,0,0.3); z-index: 5; }
        .card.face-down { background: #1C1C1E !important; border: none; background-image: radial-gradient(rgba(255,255,255,0.1) 1px, transparent 0); background-size: 4px 4px; }
        .card.face-down::before { content: "S"; color: rgba(255,255,255,0.15); font-size: 1rem; font-weight: 900; border: 1px solid rgba(255,255,255,0.1); padding: 1px 5px; border-radius: 4px; }

        .control-group { background: rgba(255,255,255,0.6); border-radius: 12px; padding: 12px; margin-bottom: 16px; border: 0.5px solid rgba(0,0,0,0.05); }
        .section-label { font-size: 0.65rem; font-weight: 800; color: #8E8E93; text-transform: uppercase; margin-bottom: 8px; display: block; border-bottom: 1px solid rgba(0,0,0,0.05); padding-bottom: 4px; }
        input, select, textarea { background: #FFFFFF; border: 1px solid var(--mac-border); border-radius: 6px; padding: 5px 8px; font-size: 0.8rem; outline: none; width: 100%; }
        button { font-size: 0.75rem; font-weight: 600; padding: 7px 10px; border-radius: 8px; background: #FFFFFF; border: 1px solid var(--mac-border); transition: 0.1s; width: 100%; cursor: pointer; }
        button.primary { border: none; color: white; background-color: var(--mac-blue); }
        .stats-tag { font-size: 0.75rem; font-weight: 800; color: #48484A; white-space: nowrap; }
        #riffleLog { font-size: 10px; font-weight: 800; color: #10B981; margin-top: 4px; text-align: center; min-height: 15px; }
    </style>
</head>
<body>
<div class="app-layout">
    <aside id="sidebar">
        <div class="flex justify-between items-center mb-5 lg:mb-10">
            <h1 class="font-black text-sm lg:text-xl tracking-tighter">ShuffleSim v3.9</h1>
            <div class="flex gap-2 w-auto">
                <button onclick="undo()" style="width: auto;">Undo</button>
                <button onclick="redo()" style="width: auto;">Redo</button>
            </div>
        </div>

        <div class="control-group">
            <h2 class="section-label">解析 & プリセット</h2>
            <div class="grid grid-cols-2 gap-2 mb-3">
                <button onclick="applyPreset('ndo_chased')" class="bg-blue-50 border-blue-200 text-blue-700">CHaSeD (A-K)</button>
                <button onclick="applyPreset('ndo_uspcc')">USPCC Order</button>
                <button onclick="applyPreset('mnemonica')">Mnemonica</button>
                <button onclick="applyPreset('pairAa')">A/a Pairs</button>
                <button onclick="setReference()" class="col-span-2 primary">現在を解析基準に設定</button>
            </div>
            <textarea id="customInput" rows="1" placeholder="ラベル または 枚数" class="mb-2"></textarea>
            <div class="flex gap-2"><input type="text" id="stackName" placeholder="保存名" class="flex-1"><button onclick="saveCurrentStack()" class="primary w-16 text-[0.6rem]">保存</button></div>
            <div id="customPresetList" class="mt-3"></div>
        </div>

        <div class="control-group">
            <h2 class="section-label text-green-600">リフル (ボトムから交互ドロップ)</h2>
            <div class="grid grid-cols-2 gap-2 mb-2">
                <select id="riffleSplit" onchange="toggleRiffleField()" class="col-span-2"><option value="jitter">中央付近で分ける</option><option value="fixed">枚数を指定</option></select>
                <input type="number" id="riffleFixed" value="26" class="hidden col-span-2">
                <div class="col-span-2">
                    <label class="text-[0.6rem] text-gray-400 font-bold">ドロップ枚数の範囲 (1〜n)</label>
                    <div class="flex gap-2 items-center">
                        <input type="number" id="riffleMin" value="1" class="text-center">
                        <span>~</span>
                        <input type="number" id="riffleMax" value="3" class="text-center">
                    </div>
                </div>
            </div>
            <button class="primary bg-green-600" onclick="opRiffle()">リフルを実行</button>
            <div id="riffleLog"></div>
        </div>

        <div class="control-group">
            <h2 class="section-label text-indigo-600">アドバンスド・ファロー</h2>
            <div class="grid grid-cols-2 gap-2 mb-2">
                <select id="faroMode"><option value="out">Out</option><option value="in">In</option></select>
                <select id="faroRatio"><option value="1-1">1:1</option><option value="2-2">2:2</option><option value="2-1">2:1</option></select>
                <input type="number" id="faroSplit" value="26" class="col-span-2">
            </div>
            <button class="primary bg-indigo-600" onclick="opFaro()">ファローを実行</button>
        </div>

        <div class="control-group">
            <h2 class="section-label text-gray-600">カット</h2>
            <div class="grid grid-cols-1 gap-2">
                <input type="number" id="cutN" value="1" placeholder="枚数">
                <button class="primary bg-gray-600" onclick="opCut()">カットを実行</button>
            </div>
        </div>

        <div class="control-group">
            <h2 class="section-label text-blue-600">オーバーハンド</h2>
            <div class="flex gap-2 items-center"><input type="number" id="ohMin" value="1" class="text-center w-12"><span>~</span><input type="number" id="ohMax" value="6" class="text-center w-12"><button class="primary bg-blue-600" onclick="opOverhandStep()">1束</button></div>
            <button onclick="opOverhandFinish()" class="mt-2">1周終える</button>
        </div>
    </aside>

    <main>
        <div class="stats-container">
            <div class="stats-inner" id="statsBar">
                <span class="stats-tag">枚数: 0</span><span class="stats-tag">メイト: 0</span>
            </div>
            <button onclick="copyDeckText()" class="text-[11px] font-bold text-blue-600 w-auto border-none">コピー</button>
        </div>
        <div class="flex-1 overflow-y-auto px-6 py-6 lg:px-12 bg-[#FAFAFA]" id="mainScroll">
            <div id="handArea" class="mb-10 hidden"><div class="area-label">移動した山</div><div id="handDisplay" class="card-grid"></div></div>
            <div id="deckArea"><div class="area-label" id="deckAreaLabel">デック本体</div><div id="deckDisplay" class="card-grid"></div></div>
        </div>
    </main>
</div>

<script>
    let activePileIdx = 0;
    let piles = Array.from({length: 4}, (_, i) => ({ name: String.fromCharCode(65 + i), deck: [], undoStack: [], redoStack: [], tempHand: [], referenceIds: [] }));
    let sortableInstance = null;
    const COLORS = { S: { bg: '#E0E7FF', bar: '#312E81', txt: 'suit-S' }, H: { bg: '#FFE4E6', bar: '#9F1239', txt: 'suit-H' }, C: { bg: '#D1FAE5', bar: '#065F46', txt: 'suit-C' }, D: { bg: '#FFEDD5', bar: '#9A3412', txt: 'suit-D' } };

    function saveState() { const p = piles[activePileIdx]; p.undoStack.push(JSON.parse(JSON.stringify(p.deck))); if (p.undoStack.length > 200) p.undoStack.shift(); p.redoStack = []; }
    function undo() { const p = piles[activePileIdx]; if (p.undoStack.length === 0) return; p.redoStack.push(JSON.parse(JSON.stringify(p.deck))); p.deck = p.undoStack.pop(); p.tempHand = []; render(); }
    function redo() { const p = piles[activePileIdx]; if (p.redoStack.length === 0) return; p.undoStack.push(JSON.parse(JSON.stringify(p.deck))); p.deck = p.redoStack.pop(); render(); }
    function setReference() { const p = piles[activePileIdx]; const full = [...p.tempHand, ...p.deck]; p.referenceIds = full.map(c => c.id); render(); }

    function opOverhandStep() {
        const p = piles[activePileIdx]; if (p.deck.length === 0) return; if (p.tempHand.length === 0) saveState();
        let n = Math.floor(Math.random() * (parseInt(ohMax.value) - parseInt(ohMin.value) + 1)) + parseInt(ohMin.value);
        p.tempHand = [...p.deck.splice(0, Math.min(n, p.deck.length)), ...p.tempHand]; render();
    }
    function opOverhandFinish() {
        const p = piles[activePileIdx]; if (p.deck.length === 0 && p.tempHand.length === 0) return; saveState();
        let wd = [...p.deck], wh = [...p.tempHand];
        while (wd.length > 0) { let n = Math.floor(Math.random() * (parseInt(ohMax.value)-parseInt(ohMin.value)+1))+parseInt(ohMin.value); wh = [...wd.splice(0, Math.min(n, wd.length)), ...wh]; }
        p.deck = wh; p.tempHand = []; render();
    }

    // --- 完全再実装：ボトムアップ・交互ドロップ型リフル ---
    function opRiffle() {
        const p = piles[activePileIdx]; if (p.deck.length < 2) return; saveState();
        let cp = (riffleSplit.value === 'fixed') ? parseInt(riffleFixed.value) : Math.floor(p.deck.length/2) + Math.floor(Math.random() * 7) - 3;
        
        let L = p.deck.slice(0, cp), R = p.deck.slice(cp), res = [];
        const rMin = parseInt(riffleMin.value), rMax = parseInt(riffleMax.value);

        while (L.length > 0 || R.length > 0) {
            // パケットLのボトム（配列の末尾）からドロップ
            if (L.length > 0) {
                let n = Math.floor(Math.random() * (rMax - rMin + 1)) + rMin;
                let chunk = L.splice(-Math.min(n, L.length));
                res = [...chunk, ...res]; // デックの底から積み上げる
            }
            // パケットRのボトムからドロップ
            if (R.length > 0) {
                let n = Math.floor(Math.random() * (rMax - rMin + 1)) + rMin;
                let chunk = R.splice(-Math.min(n, R.length));
                res = [...chunk, ...res];
            }
        }
        p.deck = res; 
        document.getElementById('riffleLog').innerText = `分割位置: ${cp} 枚目`; 
        render();
    }

    function opFaro() {
        const p = piles[activePileIdx]; if (p.deck.length < 2) return; saveState();
        let split = parseInt(faroSplit.value), mode = faroMode.value, ratio = faroRatio.value;
        let A = p.deck.slice(0, split), B = p.deck.slice(split);
        let f = (mode === 'out') ? A : B, s = (mode === 'out') ? B : A, res = [];
        let r1 = (ratio === '1-1' ? 1 : 2), r2 = (ratio === '2-2' ? 2 : 1);
        while (f.length > 0 || s.length > 0) { if (f.length > 0) res.push(...f.splice(0, r1)); if (s.length > 0) res.push(...s.splice(0, r2)); }
        p.deck = res; render();
    }
    function opCut() { const p = piles[activePileIdx]; if (p.deck.length === 0) return; saveState(); let n = parseInt(cutN.value) % p.deck.length; p.deck = [...p.deck.slice(n), ...p.deck.slice(0, n)]; render(); }

    function render() {
        const p = piles[activePileIdx]; const full = [...p.tempHand, ...p.deck];
        let mates = 0; for (let i = 1; i < full.length; i++) if (isMate(full[i].label, full[i-1].label)) mates++;
        document.getElementById('statsBar').innerHTML = `<span class="stats-tag">枚数: ${full.length}</span><span class="stats-tag">メイト: ${mates}</span>`;
        handArea.classList.toggle('hidden', p.tempHand.length === 0);
        handDisplay.innerHTML = ''; p.tempHand.forEach((c, i) => drawCard(c, i + 1, true, p.referenceIds, full, handDisplay));
        deckDisplay.innerHTML = ''; p.deck.forEach((c, i) => drawCard(c, p.tempHand.length + i + 1, false, p.referenceIds, full, deckDisplay));
        if (sortableInstance) sortableInstance.destroy();
        sortableInstance = Sortable.create(deckDisplay, { animation: 150, onEnd: function (e) {
            saveState(); const d = [...p.tempHand, ...p.deck]; const item = d.splice(e.oldIndex + p.tempHand.length, 1)[0]; d.splice(e.newIndex + p.tempHand.length, 0, item); p.tempHand = []; p.deck = d; render();
        }});
    }

    function isMate(l1, l2) {
        if (!l1 || !l2) return false;
        const m1 = l1.match(/^(\d+|[AJQK])([SHCD])$/), m2 = l2.match(/^(\d+|[AJQK])([SHCD])$/);
        if (m1 && m2) return m1[1] === m2[1] && ((m1[2] === 'S' || m1[2] === 'C') === (m2[2] === 'S' || m2[2] === 'C'));
        return l1.toLowerCase() === l2.toLowerCase();
    }

    function drawCard(card, pos, inHand, refIds, fullDeck, container) {
        const el = document.createElement('div');
        const cIdx = pos - 1, rIdx = refIds.indexOf(card.id);
        let cls = `card ${card.faceUp ? '' : 'face-down'} ${inHand ? 'in-hand-highlight' : ''}`;
        if (card.faceUp) {
            const m = card.label.match(/^(\d+|[AJQK])([SHCD])$/);
            if (m) { cls += ` ${COLORS[m[2]].txt}`; el.style.backgroundColor = COLORS[m[2]].bg; el.innerHTML = `<div class="rank-badge" style="background-color:${getRankColor(m[1])}"></div><span class="rank-label">${card.label}</span>`; }
            else { const key = card.label.toLowerCase(); el.style.backgroundColor = `hsl(${50 + (Math.abs(hash(key)) % 270)}, 50%, 92%)`; el.innerHTML = `<div class="rank-badge" style="background-color:${getRankColor(key)}"></div><span class="rank-label">${card.label}</span>`; }
        }
        if (rIdx !== -1) {
            let next = (cIdx < fullDeck.length - 1 && refIds[rIdx + 1] === fullDeck[cIdx + 1].id);
            let prev = (cIdx > 0 && refIds[rIdx - 1] === fullDeck[cIdx - 1].id);
            if (next || prev) cls += ' slug-active'; if (next) cls += ' slug-next'; if (prev) cls += ' slug-prev';
        }
        el.className = cls;
        const posEl = document.createElement('div'); posEl.className = 'card-pos'; posEl.innerText = pos; el.appendChild(posEl);
        el.onclick = (e) => { saveState(); if (e.shiftKey) { const d = [...piles[activePileIdx].tempHand, ...piles[activePileIdx].deck]; d.splice(pos - 1, 1); piles[activePileIdx].tempHand = []; piles[activePileIdx].deck = d; } else { card.faceUp = !card.faceUp; } render(); };
        container.appendChild(el);
    }

    function getRankColor(r) { let h = Math.abs(hash(r.toLowerCase())) % 360; return `hsla(${h}, 70%, 50%, 0.15)`; }
    function hash(s) { let h = 0; for(let i=0; i<s.length; i++) h = s.charCodeAt(i) + ((h << 5) - h); return h; }

    function applyStackString(str) {
        saveState(); const tokens = str.split(/[\s,]+/).filter(t => t);
        const newDeck = tokens.map(t => {
            let f = t.length <= 1 || !/[v*↓]$/.test(t), l = (t === '*' || t === '↓') ? '' : (f ? t : t.slice(0, -1));
            return { label: l, faceUp: f, id: Math.random().toString(36).substr(2, 9) };
        });
        piles[activePileIdx].deck = newDeck; piles[activePileIdx].tempHand = []; piles[activePileIdx].referenceIds = newDeck.map(c => c.id); render();
    }

    function applyPreset(t) {
        if (t === 'ndo_chased') { let s = ['C','H','S','D'], r = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'], res = []; s.forEach(suit => r.forEach(rank => res.push(rank + suit))); applyStackString(res.join(' ')); }
        if (t === 'ndo_uspcc') { let res = []; ['S','D'].forEach(s => ['A','2','3','4','5','6','7','8','9','10','J','Q','K'].forEach(r => res.push(r+s))); ['C','H'].forEach(s => ['K','Q','J','10','9','8','7','6','5','4','3','2','A'].forEach(r => res.push(r+s))); applyStackString(res.join(' ')); }
        if (t === 'mnemonica') applyStackString("4C 2H 7D 3C 4H 6D AS 5H 9S 2S QH 3D QC 8H 6S 5S 9H KC 2D JH 3S 8S 6H 10C 5D KD 2C 3H 8D 5C KS JD 8C 10S KH JC 7S 10H AD 4S 7H 4D AC 9C JS QD 7C QS 10D 6C AH 9D");
        if (t === 'pairAa') applyStackString("A a B b C c D d E e F f G g H i j k l m n o p q r s t u v w x y z");
    }

    function saveCurrentStack() {
        const n = stackName.value.trim(); if (!n) return alert("名前入力");
        const full = [...piles[activePileIdx].tempHand, ...piles[activePileIdx].deck];
        const p = JSON.parse(localStorage.getItem('shufflesim_custom_stacks') || '{}');
        p[n] = full.map(c => c.label + (c.faceUp ? '' : 'v')).join(' '); localStorage.setItem('shufflesim_custom_stacks', JSON.stringify(p)); stackName.value = ''; renderCustom();
    }
    function renderCustom() {
        const list = document.getElementById('customPresetList'); const p = JSON.parse(localStorage.getItem('shufflesim_custom_stacks') || '{}');
        list.innerHTML = Object.keys(p).length > 0 ? '<p class="text-[0.55rem] text-gray-400 font-bold mb-1">Custom:</p>' : '';
        for (const n in p) {
            const row = document.createElement('div'); row.className = 'flex items-center gap-1 mb-1';
            const b = document.createElement('button'); b.className = 'text-[0.7rem] bg-white border-gray-200 text-left truncate flex-1 px-2 py-1'; b.innerText = n; b.onclick = () => applyStackString(p[n]);
            const d = document.createElement('button'); d.innerText = '×'; d.style = "width:18px; height:18px; background:#ff3b30; color:white; border-radius:50%; font-size:10px; border:none;"; d.onclick = () => { delete p[n]; localStorage.setItem('shufflesim_custom_stacks', JSON.stringify(p)); renderCustom(); };
            row.appendChild(b); row.appendChild(d); list.appendChild(row);
        }
    }
    function toggleRiffleField() { riffleFixed.classList.toggle('hidden', riffleSplit.value === 'jitter'); }
    function copyDeckText() { const f = [...piles[activePileIdx].tempHand, ...piles[activePileIdx].deck]; navigator.clipboard.writeText(f.map(c => c.label + (c.faceUp ? '' : 'v')).join(' ')); alert("コピー完了"); }
    renderCustom(); render();
</script>
</body>
</html>
