<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ShuffleSim v3.4</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <style>
        :root { --mac-bg: #F2F2F7; --mac-sidebar: #E5E5EA; --mac-border: #D1D1D6; --mac-blue: #007AFF; }
        body { font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif; background-color: var(--mac-bg); color: #1C1C1E; margin: 0; padding: 0; overflow: hidden; }
        .app-layout { display: flex; flex-direction: column; height: 100vh; }
        @media (min-width: 1024px) { .app-layout { flex-direction: row; } }
        aside { background-color: var(--mac-sidebar); border-bottom: 1px solid var(--mac-border); height: 48vh; overflow-y: auto; flex-shrink: 0; z-index: 20; padding: 12px; }
        @media (min-width: 1024px) { aside { width: 340px; height: 100vh; border-bottom: none; border-right: 1px solid var(--mac-border); padding: 20px; } }
        main { flex: 1; display: flex; flex-direction: column; overflow: hidden; background: #FFFFFF; }
        
        .stats-container { background-color: #FBFBFC; border-bottom: 1px solid #E5E5E7; display: flex; align-items: center; justify-content: space-between; height: 44px; padding: 0 16px; flex-shrink: 0; }
        .stats-inner { display: flex; gap: 8px; align-items: center; background: #EEEEF0; padding: 4px 12px; border-radius: 20px; border: 0.5px solid #D1D1D6; }

        /* --- カード配色システム --- */
        .card-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(54px, 1fr)); gap: 12px; padding: 0 10px; }
        @media (min-width: 768px) { .card-grid { grid-template-columns: repeat(auto-fill, minmax(72px, 1fr)); gap: 14px; padding: 0; } }
        
        .card { aspect-ratio: 2/3; display: flex; flex-direction: column; align-items: center; justify-content: center; border-radius: 8px; font-weight: 800; font-size: 0.85rem; cursor: grab; background: #FFFFFF; border: 1.5px solid rgba(0,0,0,0.1); box-shadow: 0 1px 3px rgba(0,0,0,0.08); position: relative; overflow: hidden; transition: transform 0.1s; }
        
        /* スート別背景色 */
        .suit-S { background-color: #E0E7FF !important; color: #312E81; border-color: #C7D2FE; } /* Indigo */
        .suit-H { background-color: #FFE4E6 !important; color: #9F1239; border-color: #FECDD3; } /* Rose */
        .suit-C { background-color: #D1FAE5 !important; color: #065F46; border-color: #A7F3D0; } /* Emerald */
        .suit-D { background-color: #FFEDD5 !important; color: #9A3412; border-color: #FED7AA; } /* Orange */

        /* ランクアクセント（メイト・ペア識別用） */
        .rank-badge { position: absolute; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; background-color: rgba(255,255,255,0.4); z-index: 1; border: 1px solid rgba(0,0,0,0.05); }
        .rank-label { position: relative; z-index: 2; }

        /* スラッグ連結表示（青いフレーム） */
        .slug-active { border: 2.5px solid var(--mac-blue) !important; z-index: 10; }
        .slug-next { border-right: none !important; border-top-right-radius: 0 !important; border-bottom-right-radius: 0 !important; margin-right: -13px; }
        .slug-prev { border-left: none !important; border-top-left-radius: 0 !important; border-bottom-left-radius: 0 !important; }

        .card-pos { position: absolute; bottom: 3px; right: 5px; font-size: 0.5rem; font-weight: 900; color: rgba(0,0,0,0.3); z-index: 5; }
        .card.face-down { background: #1C1C1E !important; border: none; background-image: radial-gradient(rgba(255,255,255,0.1) 1px, transparent 0); background-size: 4px 4px; }
        .card.face-down::before { content: "S"; color: rgba(255,255,255,0.15); font-size: 1rem; font-weight: 900; border: 1px solid rgba(255,255,255,0.1); padding: 1px 5px; border-radius: 4px; }

        .control-group { background: rgba(255,255,255,0.6); border-radius: 12px; padding: 12px; margin-bottom: 16px; border: 0.5px solid rgba(0,0,0,0.05); }
        .section-label { font-size: 0.65rem; font-weight: 800; color: #8E8E93; text-transform: uppercase; margin-bottom: 8px; display: block; border-bottom: 1px solid rgba(0,0,0,0.05); padding-bottom: 4px; }
        input, select, textarea { background: #FFFFFF; border: 1px solid var(--mac-border); border-radius: 6px; padding: 5px 8px; font-size: 0.8rem; outline: none; width: 100%; }
        button { font-size: 0.75rem; font-weight: 600; padding: 7px 10px; border-radius: 8px; background: #FFFFFF; border: 1px solid var(--mac-border); transition: 0.1s; width: 100%; cursor: pointer; }
        button.primary { border: none; color: white; background-color: var(--mac-blue); }
        .stats-tag { font-size: 0.65rem; font-weight: 800; color: #48484A; white-space: nowrap; }
    </style>
</head>
<body>
<div class="app-layout">
    <aside id="sidebar">
        <div class="flex justify-between items-center mb-5 lg:mb-10">
            <h1 class="font-black text-sm lg:text-xl tracking-tighter">ShuffleSim v3.4</h1>
            <div class="flex gap-2 w-auto">
                <button onclick="undo()" style="width: auto;">Undo</button>
                <button onclick="redo()" style="width: auto;">Redo</button>
            </div>
        </div>
        <div class="control-group">
            <h2 class="section-label">解析 & 基準</h2>
            <div class="grid grid-cols-2 gap-2 mb-3">
                <button onclick="applyPreset('ndo_chased')" class="bg-blue-50 border-blue-200 text-blue-700">CHaSeD NDO</button>
                <button onclick="applyPreset('mnemonica')">Mnemonica</button>
                <button onclick="applyPreset('pairAa')">A/a Pairs</button>
                <button onclick="setReference()" class="primary">現在を解析基準に</button>
            </div>
            <textarea id="customInput" rows="1" placeholder="AS, 2S, 3S..." class="mb-2"></textarea>
            <div class="flex gap-2"><input type="text" id="stackName" placeholder="保存名" class="flex-1"><button onclick="saveCurrentStack()" class="primary w-16 text-[0.6rem]">保存</button></div>
            <div id="customPresetList" class="mt-3"></div>
        </div>
        <div class="control-group">
            <h2 class="section-label text-blue-600">オーバーハンド</h2>
            <div class="flex gap-2 items-center"><input type="number" id="ohMin" value="1" class="text-center w-12"><span>~</span><input type="number" id="ohMax" value="6" class="text-center w-12"><button class="primary bg-blue-600" onclick="opOverhandStep()">1束</button></div>
            <button onclick="opOverhandFinish()" class="mt-2">1周終える</button>
        </div>
        <div class="control-group">
            <h2 class="section-label text-green-600">リフル (交互落とし)</h2>
            <div class="grid grid-cols-2 gap-2 mb-2"><input type="number" id="chunkMax" value="3" placeholder="噛み合わせ上限"><input type="number" id="rifflePasses" value="1" placeholder="回数"></div>
            <button class="primary bg-green-600" onclick="opRiffle()">リフル実行</button>
        </div>
        <div class="control-group">
            <h2 class="section-label text-indigo-600">ファロー & カット</h2>
            <div class="grid grid-cols-2 gap-2"><select id="faroMode"><option value="out">Out</option><option value="in">In</option></select><select id="faroRatio"><option value="1-1">1:1</option><option value="2-1">2:1</option></select><button class="primary bg-indigo-600" onclick="opFaro()">Faro</button><div class="flex gap-1"><input type="number" id="cutN" value="1"><button onclick="opCut()" class="bg-gray-600 text-white border-none">Cut</button></div></div>
        </div>
    </aside>

    <main>
        <div class="stats-container">
            <div class="stats-inner" id="statsBar">
                <span class="stats-tag">枚数: 0</span><span class="stats-tag">メイト: 0</span><span class="stats-tag text-blue-600">抜き出し率: 0%</span>
            </div>
            <button onclick="copyDeckText()" class="text-[11px] font-bold text-blue-600 w-auto border-none hover:underline">コピー</button>
        </div>
        <div class="flex-1 overflow-y-auto px-6 py-6 lg:px-12 bg-[#FAFAFA]" id="mainScroll">
            <div id="handArea" class="mb-10 hidden"><div class="area-label">移動した山</div><div id="handDisplay" class="card-grid"></div></div>
            <div id="deckArea"><div class="area-label" id="deckAreaLabel">現在のデック</div><div id="deckDisplay" class="card-grid"></div></div>
        </div>
    </main>
</div>

<script>
    let activePileIdx = 0;
    let piles = Array.from({length: 4}, (_, i) => ({ name: String.fromCharCode(65 + i), deck: [], undoStack: [], redoStack: [], tempHand: [], referenceIds: [] }));
    let sortableInstance = null;

    // --- ロジック ---
    function saveState() { const p = piles[activePileIdx]; p.undoStack.push(JSON.parse(JSON.stringify(p.deck))); if (p.undoStack.length > 200) p.undoStack.shift(); p.redoStack = []; }
    function undo() { const p = piles[activePileIdx]; if (p.undoStack.length === 0) return; p.redoStack.push(JSON.parse(JSON.stringify(p.deck))); p.deck = p.undoStack.pop(); p.tempHand = []; render(); }
    function redo() { const p = piles[activePileIdx]; if (p.redoStack.length === 0) return; p.undoStack.push(JSON.parse(JSON.stringify(p.deck))); p.deck = p.redoStack.pop(); render(); }
    function setReference() { const p = piles[activePileIdx]; const full = [...p.tempHand, ...p.deck]; p.referenceIds = full.map(c => c.id); render(); }

    function opOverhandStep() {
        const p = piles[activePileIdx]; if (p.deck.length === 0) return; if (p.tempHand.length === 0) saveState();
        let n = Math.floor(Math.random() * (parseInt(ohMax.value) - parseInt(ohMin.value) + 1)) + parseInt(ohMin.value);
        p.tempHand = [...p.deck.splice(0, Math.min(n, p.deck.length)), ...p.tempHand]; render();
    }
    function opOverhandFinish() {
        const p = piles[activePileIdx]; if (p.deck.length === 0 && p.tempHand.length === 0) return; saveState();
        let wd = [...p.deck], wh = [...p.tempHand];
        while (wd.length > 0) { let n = Math.floor(Math.random() * (ohMax.value-ohMin.value+1))+parseInt(ohMin.value); wh = [...wd.splice(0, Math.min(n, wd.length)), ...wh]; }
        p.deck = wh; p.tempHand = []; render();
    }
    function opRiffle() {
        const p = piles[activePileIdx]; if (p.deck.length < 2) return; saveState();
        let cp = Math.floor(p.deck.length/2) + Math.floor(Math.random() * 7) - 3;
        let L = p.deck.slice(0, cp), R = p.deck.slice(cp), res = [];
        let turn = Math.random() < 0.5 ? 'L' : 'R';
        while (L.length > 0 || R.length > 0) {
            let s = (turn === 'L' && L.length > 0) ? L : (R.length > 0 ? R : L);
            res.push(...s.splice(0, Math.floor(Math.random() * parseInt(chunkMax.value)) + 1));
            turn = (s === L) ? 'R' : 'L';
        }
        p.deck = res; render();
    }
    function opFaro() {
        const p = piles[activePileIdx]; if (p.deck.length < 2) return; saveState();
        let mid = Math.floor(p.deck.length/2), A = p.deck.slice(0, mid), B = p.deck.slice(mid);
        let f = (faroMode.value === 'out') ? A : B, s = (faroMode.value === 'out') ? B : A, res = [];
        let r1 = faroRatio.value === '2-1' ? 2 : 1;
        while (f.length > 0 || s.length > 0) { if (f.length > 0) res.push(...f.splice(0, r1)); if (s.length > 0) res.push(s.shift()); }
        p.deck = res; render();
    }
    function opCut() { const p = piles[activePileIdx]; if (p.deck.length === 0) return; saveState(); let n = parseInt(cutN.value) % p.deck.length; p.deck = [...p.deck.slice(n), ...p.deck.slice(0, n)]; render(); }

    function getLCS(current, ref) {
        let m = current.length, n = ref.length; if (m === 0 || n === 0) return 0;
        let dp = Array.from({ length: m + 1 }, () => new Uint8Array(n + 1));
        for (let i = 1; i <= m; i++) for (let j = 1; j <= n; j++) dp[i][j] = (current[i-1] === ref[j-1]) ? dp[i-1][j-1] + 1 : Math.max(dp[i-1][j], dp[i][j-1]);
        return dp[m][n];
    }

    function render() {
        const p = piles[activePileIdx]; const full = [...p.tempHand, ...p.deck];
        let mates = 0; for (let i = 1; i < full.length; i++) if (isMate(full[i].label, full[i-1].label)) mates++;
        const lcsLen = getLCS(full.map(c=>c.id), p.referenceIds);
        const survival = p.referenceIds.length > 0 ? ((lcsLen / p.referenceIds.length) * 100).toFixed(1) : "0";

        document.getElementById('statsBar').innerHTML = `
            <span class="stats-tag">枚数: ${full.length}</span><span class="stats-tag">メイト: ${mates}</span><span class="stats-tag text-blue-600">抜き出し率: ${survival}%</span>
        `;
        
        handArea.classList.toggle('hidden', p.tempHand.length === 0);
        handDisplay.innerHTML = ''; p.tempHand.forEach((c, i) => drawCard(c, i + 1, true, p.referenceIds, full, handDisplay));
        deckDisplay.innerHTML = ''; p.deck.forEach((c, i) => drawCard(c, p.tempHand.length + i + 1, false, p.referenceIds, full, deckDisplay));
        if (sortableInstance) sortableInstance.destroy();
        sortableInstance = Sortable.create(deckDisplay, { animation: 150, onEnd: function (e) {
            saveState(); const d = [...p.tempHand, ...p.deck]; const item = d.splice(e.oldIndex + p.tempHand.length, 1)[0]; d.splice(e.newIndex + p.tempHand.length, 0, item); p.tempHand = []; p.deck = d; render();
        }});
    }

    function isMate(l1, l2) {
        if (!l1 || !l2) return false;
        const m1 = l1.match(/^(\d+|[AJQK])([SHCD])$/), m2 = l2.match(/^(\d+|[AJQK])([SHCD])$/);
        if (m1 && m2) return m1[1] === m2[1] && ((m1[2] === 'S' || m1[2] === 'C') === (m2[2] === 'S' || m2[2] === 'C'));
        return l1.toLowerCase() === l2.toLowerCase();
    }

    function drawCard(card, pos, inHand, refIds, fullDeck, container) {
        const el = document.createElement('div');
        const cIdx = pos - 1; const rIdx = refIds.indexOf(card.id);
        
        let cls = `card ${card.faceUp ? '' : 'face-down'} ${inHand ? 'in-hand-highlight' : ''}`;
        
        if (card.faceUp) {
            const m = card.label.match(/^(\d+|[AJQK])([SHCD])$/);
            if (m) {
                cls += ` suit-${m[2]}`; // スート背景色
                el.innerHTML = `<div class="rank-badge" style="background-color:${getRankColor(m[1])}"></div><span class="rank-label">${card.label}</span>`;
            } else {
                const key = card.label.toLowerCase();
                const rankColor = getRankColor(key);
                el.style.backgroundColor = `hsl(${50 + (Math.abs(hashString(key)) % 270)}, 50%, 92%)`;
                el.innerHTML = `<div class="rank-badge" style="background-color:${rankColor}"></div><span class="rank-label">${card.label}</span>`;
            }
        }
        
        // スラッグ連結
        if (rIdx !== -1) {
            let next = (cIdx < fullDeck.length - 1 && refIds[rIdx + 1] === fullDeck[cIdx + 1].id);
            let prev = (cIdx > 0 && refIds[rIdx - 1] === fullDeck[cIdx - 1].id);
            if (next || prev) cls += ' slug-active'; if (next) cls += ' slug-next'; if (prev) cls += ' slug-prev';
        }
        
        el.className = cls;
        const posEl = document.createElement('div'); posEl.className = 'card-pos'; posEl.innerText = pos; el.appendChild(posEl);
        el.onclick = (e) => { saveState(); if (e.shiftKey) { const d = [...piles[activePileIdx].tempHand, ...piles[activePileIdx].deck]; d.splice(pos - 1, 1); piles[activePileIdx].tempHand = []; piles[activePileIdx].deck = d; } else { card.faceUp = !card.faceUp; } render(); };
        container.appendChild(el);
    }

    function getRankColor(rank) {
        let h = Math.abs(hashString(rank.toLowerCase())) % 360;
        return `hsla(${h}, 70%, 50%, 0.15)`;
    }

    function hashString(str) { let h = 0; for(let i=0; i<str.length; i++) h = str.charCodeAt(i) + ((h << 5) - h); return h; }

    function applyStackString(str) {
        saveState(); const tokens = str.split(/[\s,]+/).filter(t => t);
        const newDeck = tokens.map(t => {
            let f = t.length <= 1 || !/[v*↓]$/.test(t), l = (t === '*' || t === '↓') ? '' : (f ? t : t.slice(0, -1));
            return { label: l, faceUp: f, id: Math.random().toString(36).substr(2, 9) };
        });
        piles[activePileIdx].deck = newDeck; piles[activePileIdx].tempHand = []; piles[activePileIdx].referenceIds = newDeck.map(c => c.id); render();
    }

    function applyPreset(t) {
        if (t === 'ndo_chased') { const s = ['C','H','S','D'], r = ['A','2','3','4','5','6','7','8','9','10','J','Q','K']; let res = []; s.forEach(suit => r.forEach(rank => res.push(rank + suit))); applyStackString(res.join(' ')); }
        if (t === 'mnemonica') applyStackString("4C 2H 7D 3C 4H 6D AS 5H 9S 2S QH 3D QC 8H 6S 5S 9H KC 2D JH 3S 8S 6H 10C 5D KD 2C 3H 8D 5C KS JD 8C 10S KH JC 7S 10H AD 4S 7H 4D AC 9C JS QD 7C QS 10D 6C AH 9D");
        if (t === 'pairAa') applyStackString("A a B b C c D d E e F f G g H i j k l m n o p q r s t u v w x y z");
    }

    function saveCurrentStack() {
        const name = stackName.value.trim(); if (!name) return alert("名前を入力");
        const full = [...piles[activePileIdx].tempHand, ...piles[activePileIdx].deck];
        const p = JSON.parse(localStorage.getItem('shufflesim_custom_stacks') || '{}');
        p[name] = full.map(c => c.label + (c.faceUp ? '' : 'v')).join(' ');
        localStorage.setItem('shufflesim_custom_stacks', JSON.stringify(p)); stackName.value = ''; renderCustom();
    }
    function renderCustom() {
        const list = document.getElementById('customPresetList'); const p = JSON.parse(localStorage.getItem('shufflesim_custom_stacks') || '{}');
        list.innerHTML = Object.keys(p).length > 0 ? '<p class="text-[0.55rem] text-gray-400 font-bold mb-1">Custom Stacks:</p>' : '';
        for (const n in p) {
            const row = document.createElement('div'); row.className = 'flex items-center gap-1 mb-1';
            const b = document.createElement('button'); b.className = 'text-[0.7rem] bg-white border-gray-200 text-left truncate flex-1 px-2 py-1'; b.innerText = n; b.onclick = () => applyStackString(p[n]);
            const d = document.createElement('button'); d.innerText = '×'; d.style = "width:18px; height:18px; background:#ff3b30; color:white; border-radius:50%; font-size:10px; border:none;"; d.onclick = () => { delete p[n]; localStorage.setItem('shufflesim_custom_stacks', JSON.stringify(p)); renderCustom(); };
            row.appendChild(b); row.appendChild(d); list.appendChild(row);
        }
    }
    function copyDeckText() { const f = [...piles[activePileIdx].tempHand, ...piles[activePileIdx].deck]; navigator.clipboard.writeText(f.map(c => c.label + (c.faceUp ? '' : 'v')).join(' ')); alert("コピー完了"); }
    renderCustom(); render();
</script>
</body>
</html>
