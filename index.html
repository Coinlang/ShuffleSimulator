<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShuffleSim v1.8</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <style>
        :root {
            --mac-bg: #F2F2F7;
            --mac-sidebar: #E5E5EA;
            --mac-border: #D1D1D6;
            --mac-blue: #007AFF;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif;
            background-color: var(--mac-bg);
            color: #1C1C1E;
            -webkit-font-smoothing: antialiased;
        }

        aside { background-color: var(--mac-sidebar); border-right: 1px solid var(--mac-border); }

        /* カードデザイン */
        .card-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(72px, 1fr)); gap: 14px; }
        .card {
            aspect-ratio: 2/3;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            border-radius: 10px; font-weight: 700; font-size: 0.95rem; cursor: grab;
            background: #FFFFFF; border: 0.5px solid rgba(0,0,0,0.15);
            box-shadow: 0 2px 4px rgba(0,0,0,0.04);
            transition: all 0.1s;
            position: relative;
        }
        .card:hover { border-color: var(--mac-blue); z-index: 10; }
        
        .card-pos {
            position: absolute; bottom: 6px; right: 8px;
            font-size: 0.6rem; font-weight: 900; color: #AEAEB2;
        }

        .card.face-down { background: #1C1C1E !important; border: none; }
        .card.face-down .card-label { display: none; }
        .card.face-down::before { content: ""; color: rgba(255,255,255,0.05); font-size: 1.8rem; }

        .text-red-suit { color: #FF3B30 !important; }

        /* サイドバー項目 */
        .control-group {
            background: rgba(255,255,255,0.5);
            border-radius: 14px; padding: 14px; margin-bottom: 16px;
            border: 0.5px solid rgba(0,0,0,0.05);
        }
        .section-label { font-size: 0.65rem; font-weight: 800; color: #8E8E93; text-transform: uppercase; margin-bottom: 10px; display: block; }

        input, select, textarea {
            background: #FFFFFF; border: 1px solid var(--mac-border); border-radius: 8px;
            padding: 6px 10px; font-size: 0.85rem; width: 100%; outline: none;
        }
        input:focus { border-color: var(--mac-blue); }
        
        button {
            font-size: 0.8rem; font-weight: 600; padding: 8px 12px; border-radius: 8px;
            background: #FFFFFF; border: 1px solid var(--mac-border); transition: 0.1s;
        }
        button:hover { background: #F2F2F7; }
        button:active { transform: scale(0.97); }
        button.primary { border: none; color: white; }

        .stats-tag { font-size: 0.75rem; font-weight: 700; color: #48484A; background: #FFFFFF; padding: 4px 14px; border-radius: 20px; border: 0.5px solid var(--mac-border); }
        .in-hand-highlight { border: 2px solid var(--mac-blue) !important; background: #F0F7FF !important; }
        
        .area-label { font-size: 0.6rem; font-weight: 900; color: var(--mac-blue); margin-bottom: 8px; text-transform: uppercase; }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden">

<header class="h-14 flex items-center justify-between px-6 bg-white border-b border-gray-200 z-10 shadow-sm">
    <div class="flex items-center gap-4">
        <div class="flex gap-2">
            <div class="w-3 h-3 rounded-full bg-[#FF5F57]"></div>
            <div class="w-3 h-3 rounded-full bg-[#FEBC2E]"></div>
            <div class="w-3 h-3 rounded-full bg-[#28C840]"></div>
        </div>
        <span class="font-bold text-sm text-gray-900 tracking-tight">ShuffleSim v1.8</span>
    </div>
    <div class="flex gap-2">
        <button onclick="undo()">Undo</button>
        <button onclick="redo()">Redo</button>
        <button onclick="copyDeckText()" class="primary bg-black">結果をコピー</button>
    </div>
</header>

<div class="flex flex-1 overflow-hidden">
    <aside class="w-80 p-5 overflow-y-auto shrink-0 shadow-inner">
        
        <div class="control-group">
            <h2 class="section-label">準備</h2>
            <div class="grid grid-cols-1 gap-2">
                <button onclick="applyPreset('pairAa')">A/a ペア生成</button>
                <button onclick="applyPreset('ndo')">新品の並び (NDO)</button>
                <button onclick="applyPreset('mnemonica')">Mnemonica スタック</button>
            </div>
            <textarea id="customInput" rows="2" class="mt-3" placeholder="AS 2S 3Sv..."></textarea>
            <button class="w-full mt-2" onclick="applyCustom()">適用</button>
        </div>

        <div class="control-group">
            <h2 class="section-label text-blue-600">オーバーハンド</h2>
            <div class="grid grid-cols-1 gap-3 mb-3">
                <label class="text-[0.6rem] font-black text-gray-400 block mb-[-8px]">1束の枚数 (最小~最大)</label>
                <div class="flex items-center gap-2">
                    <input type="number" id="ohMin" value="1">
                    <span class="text-gray-300">~</span>
                    <input type="number" id="ohMax" value="6">
                </div>
                <div class="flex gap-2">
                    <button class="flex-1 primary bg-blue-600" onclick="opOverhandStep()">1束剥ぐ</button>
                    <button class="flex-1" onclick="opOverhandFinish()">1周終える</button>
                </div>
            </div>
        </div>

        <div class="control-group">
            <h2 class="section-label text-green-600">リフル</h2>
            <div class="grid grid-cols-1 gap-3">
                <select id="riffleSplit" onchange="toggleRiffleField()">
                    <option value="jitter">中央付近でランダム</option>
                    <option value="fixed">正確な枚数で分ける</option>
                </select>
                <input type="number" id="riffleFixed" value="26" class="hidden">
                <div class="flex gap-2">
                    <div class="flex-1">
                        <label class="text-[0.6rem] font-black text-gray-400">噛み合わせ最大</label>
                        <input type="number" id="chunkMax" value="3">
                    </div>
                    <div class="w-16">
                        <label class="text-[0.6rem] font-black text-gray-400">回数</label>
                        <input type="number" id="rifflePasses" value="1">
                    </div>
                </div>
            </div>
            <button class="w-full primary bg-green-600 mt-2" onclick="opRiffle()">リフル実行</button>
        </div>

        <div class="control-group">
            <h2 class="section-label text-indigo-600">ファロー</h2>
            <div class="grid grid-cols-2 gap-2 mb-3">
                <select id="faroMode"><option value="out">Out</option><option value="in">In</option></select>
                <select id="faroRatio"><option value="1-1">1:1</option><option value="2-2">2:2</option><option value="2-1">2:1</option></select>
                <input type="number" id="faroSplit" value="26" class="col-span-2" placeholder="分割位置">
            </div>
            <button class="w-full primary bg-indigo-600" onclick="opFaro()">ファロー実行</button>
        </div>

        <div class="control-group">
            <h2 class="section-label">カット</h2>
            <input type="number" id="cutN" value="1" class="mb-2">
            <button class="w-full primary bg-gray-600" onclick="opCut()">カット実行</button>
        </div>
    </aside>

    <main class="flex-1 flex flex-col overflow-hidden bg-white">
        <div class="h-12 px-6 border-b border-gray-100 flex items-center justify-between">
            <div id="tabsContainer" class="flex gap-8"></div>
            <div id="statsBar" class="flex gap-3"></div>
            <div class="flex items-center gap-3 border-l pl-5">
                <span class="text-[10px] font-black text-gray-300 uppercase">Seed:</span>
                <input type="text" id="seedInput" class="w-20 h-7 text-[10px] font-mono" placeholder="Auto">
            </div>
        </div>
        <div class="flex-1 overflow-y-auto p-10 bg-[#FAFAFA]" id="deckAreaContainer">
            <div id="handArea" class="mb-10 hidden">
                <div class="area-label">移動した山 (Moved to Hand)</div>
                <div id="handDisplay" class="card-grid"></div>
            </div>
            <div id="deckArea">
                <div class="area-label">現在の山 (Remaining Deck)</div>
                <div id="deckDisplay" class="card-grid"></div>
            </div>
        </div>
    </main>
</div>

<script>
    let activePileIdx = 0;
    const piles = Array.from({length: 4}, (_, i) => ({
        name: String.fromCharCode(65 + i), deck: [], undoStack: [], redoStack: [], tempHand: []
    }));

    let sortableInstance = null;

    function toggleRiffleField() {
        document.getElementById('riffleFixed').classList.toggle('hidden', document.getElementById('riffleSplit').value === 'jitter');
    }

    function saveState() {
        const p = piles[activePileIdx];
        p.undoStack.push(JSON.parse(JSON.stringify(p.deck)));
        if (p.undoStack.length > 200) p.undoStack.shift();
        p.redoStack = [];
    }

    function undo() {
        const p = piles[activePileIdx];
        if (p.undoStack.length === 0) return;
        p.redoStack.push(JSON.parse(JSON.stringify(p.deck)));
        p.deck = p.undoStack.pop();
        p.tempHand = [];
        render();
    }

    function redo() {
        const p = piles[activePileIdx];
        if (p.redoStack.length === 0) return;
        p.undoStack.push(JSON.parse(JSON.stringify(p.deck)));
        p.deck = p.redoStack.pop();
        render();
    }

    function getRNG() {
        const seedStr = document.getElementById('seedInput').value;
        if (!seedStr) return Math.random;
        let hash = 0;
        for (let i = 0; i < seedStr.length; i++) hash = ((hash << 5) - hash) + seedStr.charCodeAt(i);
        let state = hash;
        return function() {
            state |= 0; state = state + 0x6D2B79F5 | 0;
            let t = Math.imul(state ^ state >>> 15, 1 | state);
            t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        };
    }

    // 修正：末尾の v 削除ロジックを廃止。大文字小文字の統一のみ行う。
    function getPairKey(label) {
        return label.toLowerCase();
    }

    function getColorFromKey(key) {
        if (!key) return '#FFFFFF';
        let hash = 0;
        for (let i = 0; i < key.length; i++) hash = key.charCodeAt(i) + ((hash << 5) - hash);
        // 赤を避ける(Hue 50-320に限定)
        const hue = 50 + (Math.abs(hash) % 270); 
        return `hsl(${hue}, 45%, 96%)`;
    }

    // --- オーバーハンド操作の再構築 ---
    function opOverhandStep() {
        const p = piles[activePileIdx];
        if (p.deck.length === 0) return;
        
        if (p.tempHand.length === 0) saveState();
        
        const rng = getRNG();
        const min = parseInt(document.getElementById('ohMin').value) || 1;
        const max = parseInt(document.getElementById('ohMax').value) || 6;
        
        let n = Math.floor(rng() * (max - min + 1)) + min;
        const bundle = p.deck.splice(0, Math.min(n, p.deck.length));
        
        // 束を新しい山（手元）の「上」に重ねる
        p.tempHand = [...bundle, ...p.tempHand];
        
        render();
    }

    function opOverhandFinish() {
        const p = piles[activePileIdx];
        if (p.deck.length === 0) return;
        
        saveState();
        const rng = getRNG();
        const min = parseInt(document.getElementById('ohMin').value) || 1;
        const max = parseInt(document.getElementById('ohMax').value) || 6;

        let workingDeck = [...p.deck];
        let workingHand = [...p.tempHand];

        while (workingDeck.length > 0) {
            let n = Math.floor(rng() * (max - min + 1)) + min;
            let bundle = workingDeck.splice(0, Math.min(n, workingDeck.length));
            // 常に上（先頭）に挿入することで、数学的オーバーハンドを再現
            workingHand = [...bundle, ...workingHand];
        }

        p.deck = workingHand;
        p.tempHand = [];
        render();
    }

    function opRiffle() {
        const p = piles[activePileIdx];
        if (p.deck.length < 2) return;
        saveState();
        const rng = getRNG();
        const passes = parseInt(document.getElementById('rifflePasses').value) || 1;
        const splitMode = document.getElementById('riffleSplit').value;
        const fixedVal = parseInt(document.getElementById('riffleFixed').value);
        const cMax = parseInt(document.getElementById('chunkMax').value);
        for (let ps = 0; ps < passes; ps++) {
            let L = p.deck.length;
            let cutPoint = (splitMode === 'fixed') ? Math.min(Math.max(0, fixedVal), L) : Math.floor(L/2) + Math.floor(rng() * 7) - 3;
            let left = p.deck.slice(0, cutPoint), right = p.deck.slice(cutPoint);
            let result = [];
            while (left.length > 0 || right.length > 0) {
                let side = (left.length > 0 && right.length > 0) ? (rng() < 0.5 ? left : right) : (left.length > 0 ? left : right);
                let n = Math.floor(rng() * cMax) + 1;
                result.push(...side.splice(0, Math.min(n, side.length)));
            }
            p.deck = result;
        }
        render();
    }

    function opFaro() {
        const p = piles[activePileIdx];
        if (p.deck.length < 2) return;
        saveState();
        const split = parseInt(document.getElementById('faroSplit').value);
        const mode = document.getElementById('faroMode').value;
        const ratio = document.getElementById('faroRatio').value;
        let A = p.deck.slice(0, split), B = p.deck.slice(split);
        let first = (mode === 'out') ? A : B, second = (mode === 'out') ? B : A;
        let result = [], r1 = 1, r2 = 1;
        if (ratio === '2-2') { r1 = 2; r2 = 2; }
        if (ratio === '2-1') { r1 = 2; r2 = 1; }
        while (first.length > 0 || second.length > 0) {
            if (first.length > 0) result.push(...first.splice(0, r1));
            if (second.length > 0) result.push(...second.splice(0, r2));
        }
        p.deck = result;
        render();
    }

    function opCut() {
        saveState();
        const d = piles[activePileIdx].deck;
        let n = parseInt(document.getElementById('cutN').value) % d.length;
        if (n < 0) n += d.length;
        piles[activePileIdx].deck = [...d.slice(n), ...d.slice(0, n)];
        render();
    }

    function render() {
        const tabContainer = document.getElementById('tabsContainer');
        tabContainer.innerHTML = '';
        piles.forEach((p, i) => {
            const el = document.createElement('div');
            const isActive = i === activePileIdx;
            el.className = `text-[11px] font-black cursor-pointer transition-all ${isActive ? 'text-black border-b-2 border-black pb-1' : 'text-gray-400 hover:text-gray-500'}`;
            el.innerText = `パイル ${p.name} (${p.deck.length + p.tempHand.length})`;
            el.onclick = () => { activePileIdx = i; render(); };
            tabContainer.appendChild(el);
        });

        const p = piles[activePileIdx];
        const fullDeck = [...p.tempHand, ...p.deck];
        let adj = 0;
        for (let i = 1; i < fullDeck.length; i++) {
            if (getPairKey(fullDeck[i].label) === getPairKey(fullDeck[i-1].label)) adj++;
        }
        document.getElementById('statsBar').innerHTML = `<span class="stats-tag">隣接ペア: ${adj}</span>`;

        // エリアの表示制御
        const handArea = document.getElementById('handArea');
        handArea.classList.toggle('hidden', p.tempHand.length === 0);
        
        const handDisplay = document.getElementById('handDisplay');
        handDisplay.innerHTML = '';
        p.tempHand.forEach((card, idx) => handDisplay.appendChild(createCardEl(card, idx + 1, true)));

        const deckDisplay = document.getElementById('deckDisplay');
        deckDisplay.innerHTML = '';
        p.deck.forEach((card, idx) => deckDisplay.appendChild(createCardEl(card, p.tempHand.length + idx + 1, false)));

        if (sortableInstance) sortableInstance.destroy();
        sortableInstance = Sortable.create(deckDisplay, { animation: 150, onEnd: function (evt) {
            saveState();
            const d = [...p.tempHand, ...p.deck];
            const item = d.splice(evt.oldIndex + p.tempHand.length, 1)[0];
            d.splice(evt.newIndex + p.tempHand.length, 0, item);
            p.tempHand = []; p.deck = d; render();
        }});
    }

    function createCardEl(card, pos, inHand) {
        const el = document.createElement('div');
        el.className = `card ${card.faceUp ? '' : 'face-down'} ${inHand ? 'in-hand-highlight' : ''}`;
        const posEl = document.createElement('div');
        posEl.className = 'card-pos';
        posEl.innerText = pos;
        el.appendChild(posEl);
        if (card.faceUp) {
            el.style.backgroundColor = getColorFromKey(getPairKey(card.label));
            const span = document.createElement('span');
            span.innerText = card.label;
            if (/^(?:[AJQK1-9]|10)[HD]$/.test(card.label)) span.classList.add('text-red-suit');
            el.appendChild(span);
        }
        el.onclick = (e) => {
            saveState();
            if (e.shiftKey) { 
                const d = [...piles[activePileIdx].tempHand, ...piles[activePileIdx].deck];
                d.splice(pos - 1, 1);
                piles[activePileIdx].tempHand = []; piles[activePileIdx].deck = d;
            } else { card.faceUp = !card.faceUp; }
            render();
        };
        return el;
    }

    function applyPreset(type) {
        saveState();
        let newDeck = [];
        const createCard = (label, faceUp = true) => ({ label, faceUp, id: Math.random().toString(36).substr(2, 9) });
        if (type === 'pairAa') "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split('').forEach(l => newDeck.push(createCard(l), createCard(l.toLowerCase())));
        if (type === 'ndo') ['S','D','C','H'].forEach(suit => {
            const rs = (suit === 'C' || suit === 'H') ? ['K','Q','J','10','9','8','7','6','5','4','3','2','A'] : ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
            rs.forEach(r => newDeck.push(createCard(r+suit)));
        });
        if (type === 'mnemonica') {
            const s = "4C 2H 7D 3C 4H 6D AS 5H 9S 2S QH 3D QC 8H 6S 5S 9H KC 2D JH 3S 8S 6H 10C 5D KD 2C 3H 8D 5C KS JD 8C 10S KH JC 7S 10H AD 4S 7H 4D AC 9C JS QD 7C QS 10D 6C AH 9D";
            s.split(' ').forEach(l => newDeck.push(createCard(l)));
        }
        piles[activePileIdx].deck = newDeck;
        piles[activePileIdx].tempHand = [];
        render();
    }

    function applyCustom() {
        const val = document.getElementById('customInput').value.trim();
        if (!val) return;
        saveState();
        const createCard = (label, faceUp = true) => ({ label, faceUp, id: Math.random().toString(36).substr(2, 9) });
        if (!isNaN(val)) piles[activePileIdx].deck = Array.from({length: parseInt(val)}, (_, i) => createCard(String(i + 1)));
        else {
            piles[activePileIdx].deck = val.split(/[\s, \n]+/).filter(t => t).map(t => {
                let f = true, l = t;
                if (/[v*↓]$/.test(t)) { f = false; l = t.substring(0, t.length - 1); }
                return createCard(l, f);
            });
        }
        piles[activePileIdx].tempHand = [];
        render();
    }

    function copyDeckText() {
        const full = [...piles[activePileIdx].tempHand, ...piles[activePileIdx].deck];
        navigator.clipboard.writeText(full.map(c => c.label + (c.faceUp ? '' : 'v')).join(' '));
        alert("コピーしました");
    }

    render();
</script>
</body>
</html>
